[{"content":"\n\n[Processing.R](https://github.com/gaocegege/Processing.R) 是我在 [Jeremy Douglass](http://jeremydouglass.com/) 指导下，为 [Processing](https://processing.org/) 实现的一个 R 语言模式，这是一个 [Google Summer of Code 2017](https://summerofcode.withgoogle.com/projects/) 项目。这篇文章会讲一讲它的应用，以及实现。\n\n至于这篇文章的受众，我也不是很清楚 ┑(￣Д ￣)┍ 爱看就看看吧 =。=\n\n## Processing 是什么\n\n这里有一篇文章：[Processing是干嘛的？艺术家学编程能做什么？](https://zhuanlan.zhihu.com/p/25432507)，我个人觉得介绍的很到位。我这里就再稍微说一下，我对 Processing 的看法。\n\nProcessing 从功能上而言，是一个做 creative coding 的编程语言，Processing 的 IDE 也直接被称作 Processing Development Environment（缩写 PDE）。\n\n从一个软件工程师的角度来讲，Processing 跟传统的编程语言最大的不同在于，一个完整的 Processing 程序（在 Processing 的语境中，完整的程序被称作 Sketch），一定会有一个图形化的输出。这个输出可以是 2D 图形，3D 图形，也可以是动画，等等。Processing 本身是用 Java 实现了一个编译器，其本身的语法也是跟 Java 几乎一致，因此可以把它当做 Java 的一个 DSL（对语言学不是很懂啦）。Processing 为了使得用户能够更好地进行图形化编程，实现了很多简练的函数，使得寥寥数行就可以实现一个非常简单的图形化应用。\n\n从一个艺术家的角度来讲，因为我不是一个艺术家，我也不知道怎么讲，所以就随便讲讲。绝大多数艺术家，在我看来，在写代码的能力上可能稍微有所欠缺（希望没有冒犯到你）。因此，Processing 对于他们而言，最吸引人的点应该是在于其简单易用。\n\n### 一个简单的例子\n\n这里以一个非常简单的例子介绍 Processing 可以做的事情。\n\n```\nvoid setup() {\n  size(640, 360);\n  background(102);\n}\n\nvoid draw() {\n  // Call the variableEllipse() method and send it the\n  // parameters for the current mouse position\n  // and the previous mouse position\n  variableEllipse(mouseX, mouseY, pmouseX, pmouseY);\n}\n\n\n// The simple method variableEllipse() was created specifically \n// for this program. It calculates the speed of the mouse\n// and draws a small ellipse if the mouse is moving slowly\n// and draws a large ellipse if the mouse is moving quickly \n\nvoid variableEllipse(int x, int y, int px, int py) {\n  float speed = abs(x-px) + abs(y-py);\n  stroke(speed);\n  ellipse(x, y, speed, speed);\n}\n```\n\n先讲效果，这段代码会根据鼠标的位置和鼠标移动的速度在画布上不停的画圆。\n\n在代码中可以看到三个函数，其中 `setup` 和 `draw` 是内置函数，就像是传统编程语言中的 main 函数一样，是整个程序的入口。`setup` 会进行一些设定，比如画布的大小，以及背景颜色。而每当需要绘制新的一帧时，Processing 就会调用 `draw` 函数。因此如果 `draw` 函数每次调用结果都一样，那就是一个静态的图形，如果是不一样的，得到的就是动态的效果。`variableEllipse` 是负责绘制圆形的函数。其参数是鼠标的当前坐标和上一帧的坐标，它会根据坐标计算速度，随后去绘制圆形。如果你感兴趣的话，可以去 [Examples - Pattern](https://processing.org/examples/pattern.html) 亲自试试效果 :)\n\n## Processing.R 是什么\n\n之前提到 Processing 是基于 Java 的 DSL，而且是运行在 JVM 上的。而诸如 Python, Ruby, R 等等语言，也都有在 JVM 上的实现，因此 Processing 也可以通过切换模式的方式来使用其他语言来写 Sketch 的逻辑。\n\n而 [Processing.R](https://github.com/gaocegege/Processing.R)，就是利用 [renjin](http://www.renjin.org/) 实现的 Processing 在 R 语言上的支持。\n\n\u003cfigure\u003e\n\t\u003cimg src=\"https://github.com/gaocegege/Processing.R/raw/master/raw-docs/img/editor.png\" alt=\"Processing.R\" width=\"500\"\u003e\n\u003c/figure\u003e\n\n\u003cfigure\u003e\n\t\u003cimg src=\"https://github.com/gaocegege/Processing.R/raw/master/raw-docs/img/demo.gif\" alt=\"Processing.R Demo\" width=\"200\"\u003e\n\u003c/figure\u003e\n\nProcessing 在 R 语言上的实现，依赖了一个 JVM 上的 R 解释器，每当 Processing 需要调用 draw 等等函数时，都会转而执行 R 代码中相对的定义。目前，Processing.R 支持了绝大多数 Processing 的语法，与此同时支持 Processing 自身众多的库以及 R 语言的包（两者只测试了部分）。这使得 Processing.R 能够在拥有便捷的图形化能力的同时，使用 R 语言中各种方便的包。\n\n## 下载与安装\n\nProcessing 本身下载和安装都特别简单，而且是多平台的，在[此处](https://processing.org/download/)即可找到适合你的版本。而在 Processing 的 Contribution Manager 中的 Modes 一栏中，可以下载 Processing.R。随后在主界面右上角的下拉框中选择 R 即可。\n\n\u003cfigure\u003e\n\t\u003cimg src=\"https://user-images.githubusercontent.com/5100735/29493417-df2b614e-85c7-11e7-98c5-d9f20cf780a4.PNG\" alt=\"下载与使用\" width=\"500\"\u003e\n\u003c/figure\u003e\n\n目前 Processing.R 仍然会积极地进行维护，如果你感兴趣，可以与我联系，还有很多坑等着呢，而且也可以以这个项目为蓝本，拿去申请下一年的 Google Summer of Code，总而言之欢迎各种形式的贡献。原本想做个标题党，发现自己没有 UC 小编的能力，只好找了这么一个不明所以的标题，谢谢你还不辞辛劳地点进来看看 :)\n\n## 许可协议\n\n- 本文遵守[创作共享CC BY-NC-SA 3.0协议](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/)\n- 网络平台转载请联系 \u003cmarketing@dongyue.io\u003e\n","cover":"","link":"安利时间:_processing_+_r.html","preview":"\u003cp\u003eProcessing.R 是我在 Jeremy Douglass 指导下，为 Processing 实现的一个 R 语言模式，这是一个 Google Summer of Code 2017 项目。这篇文章会讲一讲它的应用，以及实现。\u003c/p\u003e\n","title":"安利时间: Processing + R = ?"},{"content":"\n\n[Unikernels: Beyond Containers to the Next Generation of Cloud](http://www.oreilly.com/webops-perf/free/unikernels.csp) 是 [Russ Pavlicek](https://www.linkedin.com/in/rcpavlicek/) 的一本动物书（虽然是 O'Reilly 的，但是封面不是动物，是石榴），这本书对 Unikernel 有着比较全面的介绍，而且电子书是免费的，值得一读。\n\n## 啥是 Unikernel？\n\n从 2014 年以来，容器以一种不可逆转的态势席卷了全球，Unikernel 是很多人眼中的下一个容器。如果要了解什么是 Unikernel，首先需要了解什么是 kernel，kernel 是操作系统中的一个概念。应用要运行起来，是肯定要跟硬件打交道的，但是如果让应用都直接操作硬件，那一定是一场灾难。那内核就是在应用与硬件中间的一层抽象，内核提供了对底层硬件的抽象，比如把硬盘抽象成了文件，通过文件系统进行管理。传统的内核会将所有的硬件抽象都实现在其中，其中的代表就是 Linux，这样的内核被称为宏内核（Monolithic Kernel)。在宏内核中，所有的模块，诸如进程管理，内存管理，文件系统等等都是实现在内核中的。这样虽然不存在通信问题，但是任何一个模块的 bug 会使得整个内核崩溃。\n\n于是学者们提出了微内核（Micro Kernel）的概念，在内核中只保留必要的模块，比如IPC，内存管理，CPU调度等等。而其他，诸如文件系统，网络IO等等，都放在用户态来实现。这样会使得内核不那么容易崩溃，而且内核需要的内存小了。但是由于模块间的通信需要以 IPC 的方式进行，因此有一定的 overhead，效率不如很莽的宏内核。\n\n那后来又有了混合内核（Hybrid Kernel)，把一部分不常使用的内核模块，或者是原本需要的时间就很长，因此 IPC 的 overhead 看起来就不是那么夸张的功能，移出内核，而其他的就会放在内核里。\n\n再后来还有 Exokernel，但是太长了就不讲了，这部分内容在 [CSP 课堂笔记之 UniKernel](http://gaocegege.com/Blog/csp/unikernel) 一文中有更详细的解释。\n\n直接说 Unikernel，[Unikernel 的官方解释](http://unikernel.org/)是\n\n\u003eUnikernels are specialised, single-address-space machine images constructed by using library operating systems.\n\n翻译一下就是\n\n\u003eUnikernel 是专用的，单地址空间的，使用 library OS 构建出来的镜像\n\n其最大的卖点就是在，没有用户空间与内核空间之分，只有一个连续的地址空间。这样使得 Unikernel 中只能运行一个应用，而且对于运行的应用而言，没有硬件抽象可言，所有的逻辑，包括应用逻辑和操作硬件的逻辑，都在一个地址空间中。\n\n## 这样有啥好？\n\n哦，原来 Unikernel 就是一个单一内存空间的内核镜像，其中只能有一个应用在运行，那这样有啥好呢，为啥值得我放弃 Linux 而用你这么一个看上去像是阉割版的内核呢？好处就在，小，快，安♂全 /w\\\n\nUnikernel 镜像都很小，由 [MirageOS](https://mirage.io/) 实现的一个 DNS server 才 184KB，实现的一个 web server 674 KB，小到恐怖的程度。\n\n然后就是快，启动很快。因为镜像都很小，所以起停都在毫秒级别，比传统的 kernel 要快多了。\n\n最后是安全，一般来讲，小的东西相对而言比较安全。Unikernel 中没有 Shell 可用，没有密码文件，没有多余的设备驱动，这使得 Unikernel 更加安全。\n\n## 开发测试与传统有啥不同？\n\nUnikernel 在真正实践中，如何开发与测试是一个值得关注的问题。在开发过程中，开发者可以假定自己在传统的操作系统上进行开发，而所有内核相关的功能，暂且由开发机的操作系统提供。\n\n而在测试环境中，大部分 Unikernel 的实现会将应用代码与需要的内核模块构建成 Unikernel 后，再将其跑在一个传统的操作系统上，利用传统操作系统上的工具来测试 Unikernel。以 [Rumprun](https://github.com/rumpkernel/rumprun) 为例，它可以通过 KVM/QEMU 来运行一个 Rumprun Unikernel VM，随后用 Host OS 上的 GDB 来对其进行调试，具体细节可见[此处](https://github.com/rumpkernel/wiki/wiki/Howto:-Debugging-Rumprun-with-gdb)。关于调试就介绍到此，如果你想了解更多，[Hacker News 上的这个 post](https://news.ycombinator.com/item?id=10954132) 可能会给你一些启发。\n\n在发布阶段，这是 Unikernel 最简单的事情了。Unikernel 最后的产物就是一个 kernel image，可以在 Hypervisor，Bare Metal 等等各种环境上运行。\n\n所以可以看到，其中 Unikernel 在软件过程中与传统方式最大的不同就在于调试与测试。而在发布的阶段，传统的方式可能发布的是一个应用，时髦一点那一个容器镜像，而 Unikernel 则是一个高度定制化的 kernel。\n\n## 目前的 Unikernel 项目\n\n介绍完 Unikernel，接下来将介绍下目前比较成气候的 Unikernel 项目，Unikernel 的实现大部分都是语言特定的。因为涉及到具体语言的运行时，所以很难有一个项目可以适配所有的技术栈。\n\n[MirageOS](https://mirage.io) 应该是名气最大的一个 Unikernel 项目，它是使用 OCaml 进行开发的，也是要求开发者懂 OCaml 才行。与其他 Unikernel 相比，它非常成熟，而且有一些[论文](https://mirage.io/wiki/papers)，对钟爱论文的同学非常友好。\n\n[HaLVM](https://github.com/GaloisInc/HaLVM#readme) 也是一个比较早的 Unikernel 项目，它可以帮助 Haskell 程序员们把自己的 Haskell 程序构建成 Unikernel。如果你不会 Haskell，那就算了 =。=\n\n[ClickOS](http://cnp.neclab.eu/clickos) 是一个比较独特的项目，他也非常古老了，但是原本 Click 并不是以 ClickOS 的形式出现的，原本它只是一个支持定制的 router，后来就变成了 ClickOS，一个基于 Unikernel 的 router。它也有很多[论文](http://www.read.cs.ucla.edu/click/publications)，大部分都是关于 Click 本身，而不是 Unikernel 实现的。\n\n[Rumprun](https://github.com/rumpkernel/rumprun/) 也是一个非常独特的项目，其利用了 [Rump Kernel](http://rumpkernel.org/)，理论上 POSIX 兼容的程序，都可以用 Rumprun 来构建成 Unikernel。\n\n如果这些还不能满足你的好奇心，[Open source work on unikernels](http://unikernel.org/projects/) 上列出了众多的 Unikernel 项目，如有需要还请自行浏览。\n\n## Unikernel, Docker，Hyper 与 Linuxkit\n\n对 Unikernel 的介绍就是这些了，最后再谈谈自己对目前很火的一些概念的看法，以及它们之间的联系。\n\nUnikernel，在我看来，是另一种形式上的容器。在一个 Unikernel 中，只能运行一个应用，这与容器的哲学不谋而合。但现在容器最吸引人的特性并不是它的便捷，而是在它的分发。Docker 让我们看到了，原来应用的分发可以这么无痛。而 Unikernel 与容器相比，虽然可以做的更小更安全，而且也不需要有 Docker Daemon 这样的后台程序存在，甚至不需要 Host OS，或者 Hypervisor，但是它一是与传统的软件过程有较大的出入，二是在分发等等方面不能做到像容器那样方便。所以它目前肯定不会成为主流的应用分发方式，还需要进一步探索。\n\n为了能够让 Unikernel 尽快进入生产环境，有一项工作很值得关注。\n\n![](/images/posts/unikernel/unikernel.png)\n\n在 Unikernel 里运行一个 Docker Container，想法很美好，但是同样也有很多问题。这样其实并没有利用到容器便于分发的优势，也没有完全发挥 Unikernel 的优势，我觉得这不是未来。不过作为一种折中方案值得一看，可惜从 DockerCon 15 之后就没听见什么动静了。\n\nHyper Container 的技术特别独特，之前在 [Docker 与 Hyper](http://gaocegege.com/Blog/docker-rambles) 一文中介绍过，这里不再多说。他们的实现很完整，有对标 runc 的 runv，有扩展 Kubernetes 中 container runtime 的 frakti，虽然我没有尝试过，但是我觉得是比 Docker in Unikernel 更加可行的方案，讲道理很有前途。\n\nLinuxkit 是 Docker 改名 Moby 后随之发布的一个项目。Linuxkit 严格来说是一个构建操作系统的工具集，可以用来构建 Unikernel，但是也可以用来构建最小化的 Linux Kernel，目前还不知道要往什么方向发展。\n\n这些概念或多或少都有相互重叠的部分，也没有谁一定胜过谁的说法，但都有一个特点：有趣。它们都有自己不同的应用场景，本来嘛，Docker 也不是银弹。\n\nPS：本文都是纸上谈兵，作者本人并无对 Unikernel 在生产环境中的使用经验（应该暂时也没有人有），大家看看就好，如有疏漏还请不吝指教:)\n\n## 许可协议\n\n- 本文遵守[创作共享CC BY-NC-SA 3.0协议](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/)\n- 网络平台转载请联系 \u003cmarketing@dongyue.io\u003e\n","cover":"","link":"unikernel:_从不入门到入门.html","preview":"\u003cp\u003eUnikernels: Beyond Containers to the Next Generation of Cloud 是 Russ Pavlicek 的一本动物书（虽然是 O\u0026rsquo;Reilly 的，但是封面不是动物，是石榴），这本书对 Unikernel 有着比较全面的介绍，而且电子书是免费的，值得一读。\u003c/p\u003e\n","title":"Unikernel: 从不入门到入门"},{"content":"\n\n本文的受众主要是想在暑假找点事情做，挣点外快的同学，亦或是想积累一下参与真实软件开发经验的同学。\n\n## 背景介绍\n\n[Google Summer of Code](https://developers.google.com/open-source/gsoc/)（下称作 GSoC）是谷歌组织并提供经费，面对全球（绝大多数国家）在读学生的在线编程项目。它的[官方介绍](http://write.flossmanuals.net/gsocstudentguide/what-is-google-summer-of-code/)是：\n\n\u003e Google Summer of Code (GSoC) is a global program that matches students up with open source, free software and technology-related organizations to write code and get paid to do it! The organizations provide mentors who act as guides through the entire process, from learning about the community to contributing code. The idea is to get students involved in and familiar with the open source community and help them to put their summer break to good use.\n\n即是：\n\n\u003e Google 编程之夏是一个全球性项目，旨在为学生们和开源、自由软件、技术相关的组织建立联系，让学生们贡献代码并获得报酬！组织会提供导师，在学生从熟悉社区到贡献代码的整个过程中提供指导。这个想法的目的是让学生们参与和熟悉开源社区，并帮助他们充分利用暑假时间去得到锻炼。\n\n整个活动的流程是这样的：在每年的二月末，GSoC 会公布一个 Mentoring organizations 的列表，比如 [2017 Organizations](https://summerofcode.withgoogle.com/organizations/)，这个列表是受到谷歌认可的开源社区或者组织。随后学生可以从列表中挑选出适合自己的 organization，并且在 organization 的 ideas list 中找出自己感兴趣，觉得可以胜任的 idea，提出申请。一个学生最多可以申请 5 个 idea，申请在 3 月末开始，4 月初结束。在 5 月份，Google 会公布所有入选的学生，社区会给每个学生分配一个或多个 mentor，mentor 负责指导学生的工作，并评估学生的工作是否满足了社区的要求。\n\n公布之后，会有持续一个月的 Community Bonding Period，在这个阶段学生需要尽快融入社区，跟自己的 mentor 建立联系，熟悉社区工具链，交流工具等等。6 月份开始正式的开发工作。开发工作一共有三个阶段，同时也会有三个 evaluation。每个阶段大约一个月，会有一个小目标，如果 mentor 认为你完成了阶段性的目标，Google 会在每次 evaluation 结束后发放奖金。三次一共的奖金在 1200 - 6600 美刀之间。具体的数额跟所在地的 [Purchasing Power Parity](https://developers.google.com/open-source/gsoc/help/student-stipends) 有关,中国是 3600 美刀。\n\n整个项目大概在 9 月份结束，但是社区的期望肯定是学生能够继续进行贡献，这也是他们获得新的 contributors 的一个重要途径。并且在持续贡献后，学生可以在来年的 GSoC 时申请成为 mentor，虽然 mentor 没有奖金，但是有一个 Google 组织的 Mentor Summit，据说就是公费旅游。\n\n## 名词解释\n\n因为在申请的时候不同的社区对于同一个对象的叫法都有所不同，所以这里列一些常见的名词的解释。\n\n| 名词        | 解释           |\n| ------------- |-------------|\n| Organization，组织，社区    | Google 公布的 Mentoring organizations 中的组织，可以接收学生参与 GSoC |\n| 学生，申请者    | 申请参加 Google Summer of Code 的学生 |\n| Slots         | 社区可以接收的学生数量，由 Google 决定 |\n| Mentor，导师   | 学生申请成功后社区指定的导师，指导学生的具体工作，以及负责评估完成度  |\n| Stipend，奖金，奖励   | 在学生完成阶段性目标后由 Google 发放的奖金，具体的数额跟所在地的 [Purchasing Power Parity](https://developers.google.com/open-source/gsoc/help/student-stipends) 有关  |\n| Evaluation    | 阶段性检查，mentor 会检查学生有没有达成阶段性成果，影响奖金发放 |\n\n## 申请之前的准备\n\n申请是一个比较漫长的过程，如果想更加稳妥一点，建议不要在谷歌公布 Mentoring organizations 列表后再进行准备，而是要提前选定一个或几个社区，进行持续的贡献和交流，尽可能混一个脸熟。这样与后期才开始准备申请的同学而言就有了很大的优势。除此之外，要日常性地多给开源项目做贡献。在申请的时候很多社区会要求学生提供其开源贡献的经历，无论是不是对自己社区的。这时如果你已经是其他社区的积极贡献者了，那无疑是会加分的。\n\n对于社区的选择，如果你偏向保守，可以多回顾往年的列表，有一些组织是雷打不动的，比如 Python Software Foundation, Apache 这些老牌开源社区，这些相对于其他组织，有更大的可能被谷歌选中。如果你喜欢高风险，可以事先问问社区是否有申请 GSoC organization 的打算，如果有，而且你也看好，可以选择这样的社区进行贡献。\n\n至于贡献的时间，窃以为比较理想的时间是前一年的 12 月份或者同年的 1 月份开始，就要尝试着去给社区做一些微小的工作。这些工作包括但不限于：\n\n* 贡献代码，无论什么社区，都喜欢高质量的 PR\n* Review PR，给别人的 Review 点赞\n* 提交 Bug\n* 添补更新文档\n* 在 IRC 里解决别人的问题\n\n在贡献的过程中，要注意交流，不要只是提交了就走人了，最好是可以时刻跟进，及时回复别人的信息也是一种表明你的热情的方式。\n\n## 申请\n\n### Organization 介绍\n\n申请真正开始于谷歌公布的 Mentoring organizations 列表，这里大致介绍下其内容。\n\n![](/images/posts/gsoc/processing-org.png)\n\n以 2017 年 GSoC 其中的一个开源组织 [The Processing Foundation](https://summerofcode.withgoogle.com/organizations/4962961559912448/) 为例，介绍一下 GSoC 主页上 organization 的页面布局。每个 organization 都会有一段介绍性的文字，这个不是很关键。右边的一栏是比较重要的，其中 Technologies 是方便大家在搜索 organization 的。上面的 VIEW IDEAS LIST 比较重要，一般来说每个社区会事先提出一些他们期望的 idea，学生可以就这些 idea 进行申请。当然社区也鼓励学生提出自己的 idea。其下的 Chat 和 Email 一般来说会写明该社区常用的交流工具，在申请的过程中往往需要频繁地与社区相关人员交流。\n\n### 正式申请\n\nProposal，是一个申请时很关键的材料。它是学生在申请时需要提交的一个设计文件，在其中，学生往往需要写明自己的背景（学术背景，开源贡献经历等），对 idea 的了解与认识，以及大致的实现思路和方法。Proposal 的书写是没有定式的，只要可以突出你的长处就好，这是社区对你了解的唯一途径，所以需要你把自己所有的优势都要写在其中。\n\n[Proposal for Processing.R](https://docs.google.com/document/d/1b0HhRVKtCJkDaxP9dfSwzthzX0FRv6Y_0Yk58r634TA/edit?usp=sharing) 是我在申请时的一份 Proposal，可以列为参考，介绍下常规的写法。\n\n首先是 Project Description，这个部分就是让社区知道你对 idea 没有理解错，你深刻地了解这个 idea 想做的是什么。三言两语就好了。\n\n然后是 Implementation，我个人觉得是比较重要的部分。要向社区证明你已经有了完整的实现思路，现在差的就是写代码实现而已了。\n\n其次，是 Development Process，社区肯定更喜欢那些风险低，feature 吸引人的申请。一个好的 schedule 可以让社区相信你是真的已经做好了准备。精确到天自然最好，但是基本来说比较难，周和月都是不错的选择。不过有一点需要注意，不要把所有时间都安排的满满的，还是需要有一些 buffer 的。不然看起来太假了 =。=\n\n最后是 About Me，因为我对于申请的项目而言，没有什么积累，而且没有相关领域的贡献，所以把这一项放在了最后。如果你是申请 Kubernetes，而日常是 Docker 的 contributor，那把 About Me 放在最前面是更好的选择，完全看申请而定。\n\n一般来说这些是都要有的，还有一些其他的，社区特定的要求，这个也是要注意的。这里还有一些我认为写的比较好的 proposal：\n\n* [Integrate Unikernel Runtime](https://docs.google.com/document/d/1Vld4j0B-wk1A1827gIc5fzWHJlzQVqcYQnCAKJwe_ZM/edit?usp=sharing)\n* [Optimization of Distance Between Methods in Single Java Class](https://docs.google.com/document/d/1lWXpWhUN6cE06sjQANjWxamc_X3ddbSphTRSofChLyk/edit?usp=sharing)\n\n感兴趣也可以看下。\n\n### Community Bonding Period\n\n走到这一步，离拿钱就不远了，因为 GSoC 申请比完成更难。在 Community Bonding Period，你需要跟自己的 mentor 建立联系，积极融入社区等等，但是没有量化的标准，这个就不再多说了。\n\n### 开始写码\n\n写码这个，不同的项目有不同的要求。有一部分项目是给开源的 repo 贡献代码，因此要走整个 review 的流程，这想必大家都比较熟悉，不再多说。但是还有一部分项目，是 standalone 的，就是自己开了个 repo，自己写，比如我申请到的 [Processing.R](https://github.com/gaocegege/Processing.R)。这就会有很多问题，这里也着重说一下对于这一类项目的建议。\n\n首先，要明确之前 proposal 里写的 schedule 只是为了给社区信心的，事实上在开始写码之前，mentor 会跟你重新制定计划。所以如果你在 Community Bonding Period 写了很多 feature，很可能没有用，因为 mentor 说不定会给你重新制定要求。\n\n关于 standalone 的项目，跟 mentor 以及社区其他成员的交流是很关键的。因为你的 repo 别人都是没有 watch 的，所有的变动，可能只有你和你的 mentor 知道。如何让社区里的其他人看到你的贡献，非常重要。所以尽可能多在 IRC 里跟大家分享你遇到的问题，或者你的项目中的新 feature，可能会让你感觉到自己不是玩单机游戏。\n\n其次就是要尽早引入 CI，并且所有变动都以 PR merge 的方式进行，以保证代码质量。一个人的项目，质量很容易滑坡，CI 和 PR 可以让 mentor 对你的代码有一个很好的 review 体验，他也会更加积极一点。\n\n最后是不要太肝。因为自己的项目，每个 PR 的生命周期都是由自己负责的，很容易就会进入疯狂开发的状态，但是记住上面说的，在开始写码之前，mentor 会跟你重新制定计划 :)\n\n### Evaluation 与奖金发放\n\nEvaluation 是一个双向的评估，mentor 会评估学生的工作完成度如何，学生会评估社区和 mentor 对自己的帮助是否到位，学生对社区的评估可能会影响社区明年能够参加 GSoC 以及 slots 的数量，mentor 的评估决定学生能否拿到奖金。\n\n如果通过了 evaluation，奖金会在几天内到账。\n\n## 注意事项与 Tips\n\n1. **只有**学生才可以申请 GSoC。\n1. 一般来说 GSoC 主页需要科学上网才能访问。\n1. 时差问题是申请的时候需要注意的问题，这个需要格外注意，每年都有人错过申请。\n1. 奖金的发放是通过 [Payoneer](https://www.payoneer.com/home/) 发放的，如果是非美元账户，需要支付 4% 左右的换汇费用。\n1. 第一次入选 Mentoring organizations 的组织原则上只有 1 个或者 2 个 slots。\n\n## 结语\n\n这是一篇摸鱼作，希望能够对各位有所帮助。其实大家在选择开源社区的时候可以多问问有经验的人，尽可能选择一个友好的社区作为开始，这样会在开源的路上走的远一点。。\n\n## 相关文章\n\n* [Google 编程之夏(GSoC)：海量优质项目，丰厚报酬，你竟然还不知道？](https://zhuanlan.zhihu.com/p/27330699)\n\n## 许可协议\n\n- 本文遵守[创作共享CC BY-NC-SA 3.0协议](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/)\n- 网络平台转载请联系 \u003cmarketing@dongyue.io\u003e\n","cover":"","link":"google_summer_of_code_申请指南.html","preview":"\u003cp\u003e本文的受众主要是想在暑假找点事情做，挣点外快的同学，亦或是想积累一下参与真实软件开发经验的同学。\u003c/p\u003e\n","title":"Google Summer of Code 申请指南"},{"content":"\n\n#### 转载自 [gaocegege 的博客](http://gaocegege.com/Blog/%E9%98%85%E8%AF%BB/sre-0)\n\n## SRE 介绍\n\nSRE，全称是 Site Reilability Engineer，是一个类似于运维，但是跟传统运维不一样的职业，更加偏向于 DevOps。谷歌在 [SRE-谷歌运维解密](https://book.douban.com/subject/26875239/) 一书中分享了 SRE 的工作职责，以及谷歌在自己的运维工作中的一些经验。\n\n## 本文介绍\n\n这篇博客是系列文章中的第一篇，主要分享在阅读这本书时的一些感想。这本书在我看来更加适合在分布式领域或者在运维领域工作的工程师阅读，对于一个还在念书，没有完整接触过分布式系统实现的新手来说，有些过早了。因此就当是抛砖引玉，随便写写吧。\n\n这次关注的是书中的第六章，分布式系统的监控。\n\n## 关于作者\n\n第六章的作者是 [Rob Ewaschuk](https://www.linkedin.com/in/robewaschuk)。作者主要工作的领域是分布式存储，而且在自我介绍中写道自己在谷歌干的很过瘾，16-17年是不打算换工作的。O'Reilly 摘录了他在 SRE 一书中关于分布式监控的部分，做了一本电子书 [Monitoring Distributed Systems](http://www.oreilly.com/webops-perf/free/monitoring-distributed-systems.csp)。\n\n## 阅读之前\n\n在读文章之前，我对监控的了解非常浅薄。因为无论是在学校还是在之前实习，都没有涉及到对生产系统进行监控的工作。在念了研究生之后，稍微了解了一些关于分布式监控的知识。[Dapper, a Large-Scale Distributed Systems Tracing Infrastructure](https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36356.pdf) 是谷歌在 2010 年发表的论文，是关于其内部的分布式 tracing 系统的一个介绍性的论文。Tracing 在我的理解是细粒度监控中很关键的一部分。点评开源了一套这样的系统 [CAT](https://github.com/dianping/cat)。这些系统的作用就是跟踪系统相互之间的调用。比如 Web 前端调用了后端，就会生成一个从前端指向后端的 trace 记录。业界比较常见的实现是埋点或者修改字节码，前者更加可行。在阅读之前，对于分布式监控的了解也就仅限于此了。\n\n虽说读过相关论文，但是并没有真实使用过，最多就是去过点评，见过点评的 CAT 的 dashboard 是长什么样子的。\n\n## 正文\n\n全文中提到的一些东西让我非常感兴趣。其中有一句话：\n\n\u003e我们会避免任何『魔法』系统--例如视图自动学习阈值或者自动检测故障原因的系统。\n\n之前在去大众点评学习 CAT 系统时，听他们说下一步发展规划中，就有利用机器学习来学习阈值和原因的想法。我认为谷歌在为什么要保持监控系统简单时没有说清楚，这可能是跟他们的监控规模和信奉的哲学有关。他们把这类复杂的有各种特性的系统称为『魔法』系统，因为我也没有什么发言权。但是在我看来，随着复杂性的上升，引入机器学习等等是自动化的新阶段。现在可能人工的方式或者硬编码等等方式还是可以操作的，可能谷歌考虑到监控系统要尽可能稳定吧。但是机器学习可以更好地取代人工，就像在容量规划方面，我始终认为机器学习会比经验估计的更准。\n\n书中写了四个谷歌认为的黄金监控指标，分别是延迟、流量、错误和饱和度。对于延迟，他们提到的一点对我来说特别具有启发性，那就是要区分成功请求和错误请求的延迟。这两类请求有着不同的模式，是不能混为一谈的。之前用过的少数几个监控的工具都没有区分正确与错误请求的能力。这一点是在看了这本书后才学到的。\n\n还有一个比较有趣的指标，是饱和度。饱和度是指服务容量有多满，一般是用瓶颈资源的使用率来衡量。这样衡量饱和度的方式很取巧，之前没有过工程经验，都是各种指标全看一遍，最后看哪个资源不够用了，就断定服务满载了。如果事先判断好是 Memory-bound 还是 CPU-bound 类型的服务，然后每次只需要看对应的瓶颈资源就好了。\n\n关于长尾问题，谷歌给出了一种监控的方法，使用直方分布图而不是平均值来进行展示。因为可能一小部分请求导致了长尾，但是平均值是看不出这个问题的。\n\n在监控系统构建后，有一个值得考虑的问题，是短期可用性与长期可用性的冲突。短期的可用性体现在对问题的及时修复上，而长期的可用性在于对系统造成问题的根源的消除上。看起来这两者是统一的，但是其实是冲突的。人的精力是有限的，如果一直在处理 On-Call 的问题，那必然会导致缺少时间投入到根源性问题的解决上，这时需要权衡，放弃一些 On-Call 非核心的问题，去优化系统，提高长期预期的可用性。\n\n## 下文预告\n\n下一篇文章将会谈谈有关发布工程（Releasing Engineering）的事情。\n\n## 系列文章\n\n* [Google SRE 阅读笔记(1)-监控](http://blog.dongyueweb.com/google_sre_%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%281%29-%E7%9B%91%E6%8E%A7.html)\n\n## License\n\n- This article is licensed under [CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/).\n- Please contact \u003cmarketing@dongyue.io\u003e for commerical use.\n","cover":"","link":"google_sre_阅读笔记(1)-监控.html","preview":"\u003cp\u003eSRE，全称是 Site Reilability Engineer，是一个类似于运维，但是跟传统运维不一样的职业，更加偏向于 DevOps。谷歌在 \u003ca href=\"https://book.douban.com/subject/26875239/\"\u003eSRE-谷歌运维解密\u003c/a\u003e 一书中分享了 SRE 的工作职责，以及谷歌在自己的运维工作中的一些经验。\u003c/p\u003e\n","title":"Google SRE 阅读笔记(1)-监控"},{"content":"\n\n今天为东岳搭建了一个饥荒的服务器，并不是特别复杂。饥荒对于服务器的要求是：\n\n```text\nInternet(Upload) = 8Kbytes/player/s\nRam = around 65Mbytes/player\nCPU = N/A\nVCRedist_2008 (x86)\n```\n\n因此选定配置的时候要计算下，服务器的最低配置要求。因为考虑到我们的玩家数最多也就20人左右，长期在线人数能在3-4人就不错了，因此一台1核2G内存的机器就可以满足我们的要求了。\n\n我们中的绝大多数玩家，都是在华东地区的，而只有一个美帝玩家。因此在服务器的选择上，华东节点是最合适的。在考察了包括阿里云、美团云、青云、腾讯云、Hyper.sh 在内的众多云服务提供商后，选择了最便宜的腾讯云。就流量来说，基本所有的服务商都是一个价钱，但是服务器的价格从 85 到 125 不等。Hyper.sh 因为没有华东节点，就没有关注价格。因为 steam 的 cmd 运行需要 32 位的环境，而且服务器的内存没有超过 4G，因此选择了 32位 Ubuntu 16.04.1 LTS。因为选择的云服务提供商和系统都很大众，因此在过程中并没有遇到什么坑。\n\n## 安装 steam 和 饥荒\n\n按照官方的文章，没什么好说的，不过为了简单，在搭建的过程中省略了创建用户的过程，直接在默认的用户目录下进行的。还有就是需要安装两个在官方教程中没有写到的东西：xfonts-75dpi 和 xfonts-100dpi，不然在运行 steamcmd.sh 的时候会报错 `Steam needs to be online to update`。\n\n```bash\nsudo apt-get install libgcc1\nsudo apt-get install xfonts-75dpi xfonts-100dpi\nmkdir ~/steamcmd\ncd ~/steamcmd\nwget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz\ntar -xvzf steamcmd_linux.tar.gz\n./steamcmd.sh\nlogin anonymous\n# replace \u003cuser\u003e with your current user. if you use qcloud, ubuntu is the default username.\nforce_install_dir /home/\u003cuser\u003e/steamapps/DST\napp_update 343050 validate\nquit\ncd /home/steam/steamapps/DST/bin/\n```\n\n## 添加配置文件\n\n至此游戏服务器的所有二进制和依赖都安装好了，接下来需要进行配置。在 `/home/\u003cuser\u003e/.klei/DoNotStarveTogether/Cluster_1` 目录下需要建立两个文件，cluster.ini 和 cluster_token.txt。前者是对服务器的配置，后者是在饥荒的客户端游戏中生成的一个 token，猜测会用来校验玩家是否在使用正版游戏，等等。\n\ncluster.ini 文件内容很简单：\n\n```text\n[network]\ncluster_name = \u003ccluster_name\u003e\ncluster_intention = cooperative\ncluster_description = \u003ccluster_description\u003e\ncluster_port = 10999\ncluster_password = \u003cpasswd\u003e\n\n[misc]\nconsole_enabled = true\n\n[gameplay]\nmax_players = \u003cmax_players_num\u003e\npvp = false\ngame_mode = endless\npause_when_empty = true\n```\n\ncluster_token.txt 文件的内容需要用饥荒的客户端来生成，输入 `~` 打开游戏内置的 console，输入 `TheNet:GenerateClusterToken()`，不同系统会在不同位置生成一个 token：\n\n```text\nWindows:\n/My Documents/Klei/DoNotStarveTogether/cluster_token.txt\n\nLinux:\n ~/.klei/DoNotStarveTogether/cluster_token.txt\n\nMac OS X:\n~/Documents/Klei/DoNotStarveTogether/cluster_token.txt\n```\n\n然后将文件内容拷贝到 `/home/\u003cuser\u003e/.klei/DoNotStarveTogether/Cluster_1/cluster_token.txt` 中就行。\n\n## 运行\n\n```bash\n/home/\u003cuser\u003e/steamapps/DST/bin/dontstarve_dedicated_server_nullrenderer\n```\n\n官方推荐使用 screen 来维持服务器在退出 ssh 连接后依然在运行，但你喜欢怎么做就随便了。\n\n## Reference\n\n* [Don’t Starve Together（饥荒）服务器搭建](https://www.nevermoe.com/?p=695)\n\n## License\n\n- This article is licensed under [CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/).\n- Please contact \u003cmarketing@dongyue.io\u003e for commerical use.\n","cover":"","link":"在32位_ubuntu_16.04.1_lts_上安装饥荒服务器.html","preview":"\u003cp\u003e今天为东岳搭建了一个饥荒的服务器，并不是特别复杂。\u003c/p\u003e\n","title":"在32位 Ubuntu 16.04.1 LTS 上安装饥荒服务器"},{"content":"\n\n## 简介\n\n[Ayi](https://github.com/dyweb/Ayi) 是一个跨平台的命令行工具，类似于[busybox](https://busybox.net/about.html)。\n开始于 2015 年 7 月。主要目的是为了方便配置环境和解决各种由于配置环境导致的问题，比如:\n\n\u003e - 我这里跑的好好的，怎么到了你那(服务器上)就挂了\n\u003e - 我用 Mac 自带的 PHP 和 Apache 就挺好，我不用 Vagrant 和 Nginx\n\u003e - 我就想用 Windows 下的一键安装包\n\n考虑到没钱给大家每人配个 Mac，以及东岳的男女比例。\n我们需要一个跨平台的配置环境和收集环境信息的工具，用于**快速**的解决上述问题。\n\n## 技术选型\n\n在选择 Ayi 使用的技术时主要考虑的是以下几个问题\n\n- 跨平台\n- 可维护性\n- 对于东岳其他项目的帮助\n\n\u003c!-- TODO:找不到是哪个 issue 了，倒是找到了 commit https://github.com/dyweb/Ayi/commit/3a96921ccb6b5edb7c294e2a1eab2b9e63cc130b --\u003e\n最开始和咩的考虑是使用 shell 来进行操作， 但是 shell 的问题在于很难维护，基本不可能测试。\n东岳 shell 用的很少，并且 shell 对于其他项目帮助十分有限。\n\n之后考虑到 PHP, python, java 都需要运行时，C/C++ 写起来太累， Rust 没人会 (那会还没有 Ivan 和 Codeworm)，\n就选择了 Golang，当时版本是 1.5。\n\nGolang 的主要优点是\n\n- 跨平台 \u0026 交叉编译\n- 简洁的包管理\n- 性能好，可以用来改进东岳现有的纯 PHP 服务端体系\n- 一个活跃的社区，PHP 沉浸在 CMS 和抄 Rails 中不能自拔，JS 日新月异\n- Google 老爹\n\n## 主要问题\n\n- 人太少，基本只有 @at15 (我) 一个人\n- 需求不是很明确\n- 对 Golang 语言本身很不熟悉\n- Golang 的一些工具链不是很成熟，比如不支持依赖的 vendor 。\n\n但是由于项目拖了很长时间，后面三个问题基本都解决了\n\n- 主要需求是\n  - 生成器\n  - 环境检查\n  - [git 操作的简化](https://github.com/dyweb/Ayi/tree/master/app/git)\n  - [makefile 类似的自动化工具](https://github.com/dyweb/Ayi/tree/master/util/runner)\n  - [静态 web 服务器](https://github.com/dyweb/Ayi/tree/master/app/web)\n  - [进程管理](https://github.com/dyweb/Ayi/pull/64)\n  - waka time 服务器\n  - 文件传输\n- go 的版本从 1.5 跳到了 1.7。原生支持 vendor 并且有了很多更好的依赖管理工具，比如 [glide](https://github.com/Masterminds/glide)\n\n第一个问题的话，基本无解，目前东岳经常写 Golang 的人好像只有我和策策。策策有空就要去陪妹子，自然不可能陪我来填坑。\n(要有妹子的话我还会去填坑么?)\n\n## 实现的功能\n\n### Git 操作的简化\n\n前提是：你习惯使用 Golang 的 workspace，有关 workspace 我在以前东岳的讲座中[有提到](http://dongyueweb.com/course/web/2016_Spring/environment/slide.html#/4) (btw: 按方向键`下`而不是`右`)。我个人的工作区是这样的 (`cd ~/workspace \u0026\u0026 tree -L 4`)。\n\n````\n├── bin\n│   ├── Ayi\n│   ├── glide\n│   └── ink\n├── pkg\n│   └── linux_amd64\n│       └── github.com\n│           └── dyweb\n└── src\n    └── github.com\n        ├── at15\n        │   └── at15.github.io\n        ├── dyweb\n        │   ├── Ayi\n        │   └── blog\n        └── xephonhq\n            └── xephon-b\n````\n\n当使用 `git clone` 时后面必须跟完整的 remote 地址，并且默认 clone 到当前文件夹下，而使用\n`Ayi git clone` 地址可以是浏览器地址，并且根据配置文件，可以支持非默认端口的 ssh，比如东岳的 GitLab。\n从下面的输出可以看到 `Ayi git clone github.com/at15/at15.gihub.io` 被展开成了\n`git clone git@github.com:at15/at15.github.io.git /home/at15/workspace/src/github.com/at15/at15.github.io`。\n\n````\nat15@pc4038:~/workspace|⇒  Ayi git clone github.com/at15/at15.github.io\nINFO[0000] git clone git@github.com:at15/at15.github.io.git /home/at15/workspace/src/github.com/at15/at15.github.io pkg=a.a.git\nCloning into '/home/at15/workspace/src/github.com/at15/at15.github.io'...\nremote: Counting objects: 435, done.\nremote: Total 435 (delta 0), reused 0 (delta 0), pack-reused 435\nReceiving objects: 100% (435/435), 3.56 MiB | 1.64 MiB/s, done.\nResolving deltas: 100% (234/234), done.\nChecking connectivity... done.\nINFO[0002] Sucessfully cloned to: /home/at15/workspace/src/github.com/at15/at15.github.io pkg=a.cmd\n````\n\nbtw: `Ayi` 的 log 组件看上去很像 [logrus](https://github.com/sirupsen/logrus)，但其实是[自己的轮子](https://github.com/dyweb/Ayi/pull/60)\n\n### 自动化\n\n自动化部分很类似 `npm run`，但是主要有以下区别\n\n- 使用 yaml 而不是 json, json 不支持注释，而且即使使用支持注释的 parser，编辑器也会有提示\n- 支持一个指令对应一系列命令, 类似 Travis 等 CI 的配置文件\n- 目前[新的重构](https://github.com/dyweb/Ayi/pull/64)可能会把它改成类似 + 的工具\n\n````\ndebug: true\ndep-install:\n    - go get github.com/at15/go.rice/rice\n    - go get github.com/mitchellh/gox\n    - glide install\ninstall:\n    - go build -o Ayi\n    - rice append -i github.com/dyweb/Ayi/app/web --exec Ayi\n    - sh -c \"mv Ayi $GOPATH/bin/Ayi\"\ntest:\n    - go install\n    - sh -c \"go test -v -cover $(glide novendor)\"\nscripts:\n    build: gox -output=\"build/Ayi_{{.OS}}_{{.Arch}}\"\n````\n\n内置指令如`install`, `test` 跟 `Ayi run \u003cscript-name\u003e` 都是使用 `util/runner`。\n目前准备把 runner 做成一个通用的 package，\n因此[又在重构](https://github.com/dyweb/Ayi/pull/64)来增加如下的功能\n\n- 类似 [Ansible](https://www.ansible.com/) 的更丰富的配置\n- 类似[ PM2](http://pm2.keymetrics.io/) 和 [Foreman](https://github.com/ddollar/foreman) 的进程管理\n\n### 静态服务器\n\n双击一个 html 文件多半会看不了，经典的解决方案是 `python -m SimpleHTTPServer \u003cport\u003e`，\n然而 windows 并不预装 py，而且有时候我想侧边栏显示文件树，markdown 高亮，\n遇到学习文件夹自动播放并且在没有插耳机的情况下静音。\n以前自己挖了一个坑 [doc-viewer](https://github.com/at15/doc-viewer) 。\nAyi 里目前只实现了基本的静态服务器 `Ayi web static`（不要被 help 骗了，根本没有 highlight)。\n\n````\n⇒  Ayi web static -h\nserve static file like python's SimpleHTTPServer, support highlight and markdown render inspired by https://github.com/at15/doc-viewer\n\nUsage:\n  Ayi web static [flags]\n\nGlobal Flags:\n      --config string   config file (default is $HOME/.ayi.yaml)\n  -n, --dry-run         show commands to execute\n  -p, --port int        port to listen on (default 3000)\n      --root string     server root folder\n  -v, --verbose         verbose output\n````\n\n## 使用开源库中遇到的问题\n\n虽然我们要站在巨人的肩膀上，但是站的久了就会发现有些巨人其实也有点 low，比如\n\n- 不支持 windows 的 [overall](https://github.com/go-playground/overalls)，[fork](https://github.com/at15/overalls)\n- 不支持 ignore 的 [go.rice](https://github.com/GeertJohan/go.rice), [fork](https://github.com/at15/go.rice/tree/feature/ignore) 和 [issue](https://github.com/GeertJohan/go.rice/issues/83)\n- 不支持 filter 的 [logrus](https://github.com/sirupsen/logrus)，还自带[统计运行时间的 bug](https://github.com/sirupsen/logrus/issues/457)\n\n一些库虽然 star 很高，但是其实如果仔细看代码的话会发现很多问题，同时看别人的代码可以学到一些自己以前忽略的问题，比如 Golang 里 struct 的方法的 thread safe。\n相关的 issue [dyweb/Ayi#59](https://github.com/dyweb/Ayi/issues/59) [at15/go-learning#3](https://github.com/at15/go-learning/issues/3)。\nlogrus 里对应的代码如下，作为**读者的练习**。\n\n\u003c!-- TODO: no highlight --\u003e\n````golang\n// This function is not declared with a pointer value because otherwise\n// race conditions will occur when using multiple goroutines\nfunc (entry Entry) log(level Level, msg string) {\n        var buffer *bytes.Buffer\n\tentry.Time = time.Now()\n\tentry.Level = level\n\tentry.Message = msg\n````\n\n一些(很多)开源库都维护状态都是很不乐观的，上面提到的几个开 PR 和 Feature Request 的 issue\n都是没人鸟的，既然已经看了那么多了，为什么不自己写呢？ 所以就开始造轮子了(其实还是想造轮子)。\n\nbtw: 在使用开源项目的过程中完全没有必要去埋怨作者无视你的各种请求和贡献，换位思考一下，\n你是愿意陪妹子玩一晚上呢，还是愿意改 Gayhub 上某个不认识的人反馈的 bug 呢 (没有妹子的人表示思考不出来，我选择去改 bug)。\n\n## 通用库 (轮子)\n\n自己造轮子有以下几个优点:\n\n- 方便维护\n- 代码风格一致，比如 [spf13](https://github.com/spf13/) 的 [viper](https://github.com/spf13/viper) 和 [cobra](https://github.com/spf13/cobra/)\n- 可以共用很多 code base\n\n当然关键还是程序员的天性，上面的都是借口。\n\nAyi 里抽出来的库有以下几个\n\n### Log\n\nhttps://github.com/dyweb/Ayi/tree/master/common/log 仿照 [logrus](https://github.com/sirupsen/logrus) 实现,\n目标功能类似 log4j ([logback](http://logback.qos.ch/))\n\n有以下几个特点\n\n- 支持类似 log4j 的按照 package 进行 filter，避免了:\n  - 开启 debug 之后大量输出淹没了需要的信息\n  - 为了 debug，把代码里的 debug 改成 info，忘记改回去\n- 支持更多的 Level (你想加个 Hearbreak 什么的 Level 也可以 `log.Hearbreak(\"got a good man card on New Year's Eve\")`)\n- 减少了 lock (不过没做 benchmark)\n- 移除了 logger 上与 logEntry 重复的接口\n\n之后计划\n\n- 改用 generator 生成代码，`Debugf` 和其他所有 `*f` 都只差一个单词，为什么要人写呢 (我就不说我拼写错误然后 painc 了)。\n- 支持 log4j 的 appender, transformer, xml etc.\n\n### Runner\n\n之前在自动化的部分已经基本说过了，所以就不说了(就是想加个标题)。\n\n### Structure\n\nGolang 内置的数据结构少的可怜，作为一个用了3天 python 的人当然要加一点数据结构。\n\n目前实现的有\n\n- [Set](https://github.com/dyweb/Ayi/tree/common-util/runner/common/structure)\n(一开始只有 Contains 没有 Add 用了才发现这个 Set 是 immutable 的)。\n- 没有然后了\n\n### Requests\n\n`net/http` 很好用，但是 `python` 的 `requests` 更简洁，不过这个轮子目前在[另一项目(xephon-b)里](https://github.com/xephonhq/xephon-b/tree/master/pkg/util/requests)\n\nBefore\n\n````golang\nfunc (client *KairosDBHTTPClient) Ping() error {\n\tres, err := http.Get(client.Config.Host.HostURL() + \"/api/v1/version\")\n\tif err != nil {\n\t\tlog.Warn(\"can't get kairosdb version\")\n\t\tlog.Debug(err.Error())\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\tresContent, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tlog.Warn(\"can't read response body\")\n\t\tlog.Debug(err.Error())\n\t\treturn err\n\t}\n\tvar resData map[string]string\n\tif err := json.Unmarshal(resContent, \u0026resData); err != nil {\n\t\tlog.Warn(\"can't parse json\")\n\t\tlog.Debug(err.Error())\n\t\treturn err\n\t}\n\tlog.Info(\"KairosDB version is \" + resData[\"version\"])\n\treturn nil\n}\n````\n\nAfter\n\n````golang\nfunc (client *KairosDBHTTPClient) Ping() error {\n\tversionURL := client.Config.Host.HostURL() + \"/api/v1/version\"\n\tres, err := requests.GetJSON(versionURL)\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"can't reach KairosDB via %s\", versionURL)\n\t}\n\tlog.Info(\"KairosDB version is \" + res[\"version\"])\n\treturn nil\n}\n````\n\n## 开发计划\n\n上面说了那么多，一半都是画饼，可以从 issue 里看最近的进度\n\n- [正在开发的部分](https://github.com/dyweb/Ayi/issues?q=is%3Aopen+is%3Aissue+label%3Aworking)\n- [想做但是被搁置了的 issue](https://github.com/dyweb/Ayi/issues?utf8=%E2%9C%93\u0026q=is%3Aissue%20label%3Abacklog)\n\n~~欢迎感兴趣的女同学联系我! 我的微信是 `uictor`~~\n\n预计等到国内寒假的时候很多坑可以填完了，到时候欢迎假期想了解一下 Golang 的小伙伴来玩，我会加 `help wanted` 和难度的 label。\n\n## 开发人员\n\n[GitHub 传送门](https://github.com/dyweb/Ayi/graphs/contributors)\n\n- 咩在项目开始时提交了一些 shell 脚本，但是由于转到了 Golang 以及咩一向很忙，遂弃婶\n- @kdplus (丘) 参与过 `Ayi check` 的开发，不过那时我 Golang 菜的抠脚，导致丘也在划水。\n- @gaocegege (策策) 因为周报的功能，参与过一段时间的开发，\n引入了`Godep` 交叉编译，不过最后周报的功能并没有投入实用。\n\n## 总结\n\n- 等有钱了，给大家都配 MBP\n- 自己开的坑，不能让别人填 (我去开个找妹子的坑先)\n\n## 杂项\n\n- 使用 `git log -reverse` 可以反过来看 log, 可以用来找第一个提交。\n- shell 在 windows 下基本不会有问题，因为为了使用 git，东岳所有的 windows 用户都安装了\nmsysgit (现在叫 git for windows)，它自带了 bash 和一些基本的工具。\n- 周报的功能作为 MOS 的一个项目交给了 @codeworm96, 进度见[这个issue](https://github.com/dyweb/mos/issues/1)\n- [所有带 `backlog` 标签的 issue](https://github.com/dyweb/Ayi/issues?q=is%3Aissue+label%3Abacklog+is%3Aclosed)\n\n第一个提交\n````\ncommit 19858fe3958317da08dc512116c58acbd82b2a35\nAuthor: At15 \u003cat15@outlook.com\u003e\nDate:   Sun Jul 26 13:24:38 2015 +0800\n\n    Initial commit\n````\n\n## 更新\n\n## 引用\n\n## 许可协议\n\n- 本文遵守[创作共享CC BY-NC-SA 3.0协议](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/)\n- 网络平台转载请联系 \u003cmarketing@dongyue.io\u003e\n","cover":"","link":"ayi.html","preview":"\u003cp\u003eAyi 跨平台的命令行工具(库)\u003c/p\u003e\n","title":"Ayi"}]