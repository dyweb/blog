title: "时间序列数据库漫谈"
date: 2017-07-09 01:12:45 +0000
update: 2017-07-09 01:12:45 +0000
author: at15
# NOTE: the image locate in `source` folder
# cover: "-/images/posts/example.png"
tags:
    - 时间序列数据库
    - 数据库
preview: "时间序列数据库基本概念和热点话题"

---

这篇文章是写给[东岳网络工作室](https://github.com/dyweb)的小伙伴们的 (广告:欢迎在交大的同学加入)，适用于有一定数据库背景并且想要了解时间序列数据库的人。
PS: 中文版是在[英文版](/introduction_to_time_series_database.html)之后写的，很生硬，请见谅。

目录

- 什么是时间序列数据库 (TSDB)
- 时间序列数据库数据模型
- 时间序列数据库演变
- 时间序列数据库类型
  - KairosDB
  - InfluxDB
- 热点话题
  - 低延迟
  - 数据
  - 元数据索引
  - 追踪

## 什么是时间序列数据库 (TSDB)

时间序列数据库 (Time Series Database) 相对于关系型数据库 (RDBMS) 以及 NoSQL, NewSQL 还很年轻。
但是，随着系统监控以及物联网的发展，以及开始受到更多的关注。
维基百科上对于时间序列的定义是*一系列数据点按照时间顺序排列* ,
但是我个人的理解是**存储在服务端的客户端历史**。
时间序列数据就是历史，它具有**不变性**, **唯一性**以及**可排序性**。
比如在2017年9月3日21点24分44秒，华东区的机器001的CPU使用率是10.02%，
这个值就不会像银行存款一样随着时间发生变化，不会有更新。
下一秒的使用率是一个新的数据点，其他机器的使用率在其他时间序列里。
并且数据到达服务器的顺序并不影响正确性，根据数据本身可以直接进行排序和去重。
客户端发送本地的历史到服务器端，即使服务器端挂掉了，客户端依旧继续他本来要做的事情而不受到影响。
对于很多客户端来说，发送数据到TSDB跟它的本职工作并没有关联。
比如一个静态文件服务器的主要职责是传送文件而不是上报HTTP状态码。
关系型数据库则起着完全不一样的作用，它是客户端做决定的主要依据。
这就导致时间序列数据库和关系型数据库的读写规律有很大的不同。
比如你取钱之前，银行的程序必须从数据库里找到你的那条记录，读出你的余额，确认不会透支才能把钱给你，
然后更新你的余额。
然而大多数时间序列数据库的客户端是只读(监控系统)或者只写(被监控的系统)。
并且读取数据是并不是读取特定的某条，而是读取某个时间区间内的大量数据，比如`最近1小时的CPU使用率`远比
`2017年9月3日21点24分44秒的CPU使用率`有用，脱离上下文的时间序列数据并没有什么软用。

时间序列数据跟关系型数据库有太多不同，但是有很多公司不想放弃关系型数据库。
于是就产生了一些神奇的用法，比如用 [MySQL 的 VividCortex](https://www.vividcortex.com/blog/2014/12/16/in-case-you-missed-it-building-a-time-series-database-in-mysql/),
用 [Postgres 的 Timescale](http://www.timescale.com/)。
一些人觉得特殊的问题就要特殊的解决方法，于是很多时间序列数据库从头写起，不依赖任何现有的数据库, 比如[Graphite](https://graphiteapp.org/)，[InfluxDB](https://github.com/influxdata/influxdb)。

## 时间序列数据库演变

时间序列数据库有[很多](https://xephonhq.github.io/awesome-time-series-database/?language=All&backend=All)，
所以我只列一些我个人认为具有代表意义的数据库。很多数据库并没有最初版本的发布日期，以 GitHub 上最早的 tag 作为发布日期。

- 1999/07/16 [RRDTool First release](https://en.wikipedia.org/wiki/RRDtool)
- 2009/12/30 [Graphite 0.9.5](https://github.com/graphite-project/graphite-web/releases/tag/0.9.5)
- 2011/12/23 [OpenTSDB 1.0.0](https://github.com/OpenTSDB/opentsdb/releases/tag/v1.0.0)
- 2013/05/24 [KairosDB 1.0.0-beta](https://github.com/kairosdb/kairosdb/releases/tag/v1.0.0-beta2a)
- 2013/10/24 [InfluxDB 0.0.1](https://github.com/influxdata/influxdb/releases/tag/v0.0.1)
- 2014/08/25 [Heroic 0.3.0](https://github.com/spotify/heroic/releases/tag/0.3.0)
- 2017/03/27 [TimescaleDB 0.0.1-beta](https://github.com/timescale/timescaledb/releases/tag/0.0.1-beta)

[RRDTool](https://oss.oetiker.ch/rrdtool/) 是最早的时间序列数据库，它自带画图功能，现在大部分时间序列数据库都使用[Grafana](https://github.com/grafana/grafana)来画图。
[Graphite](https://graphiteapp.org/) 是用 Python 写的 RRD 数据库，它的存储引擎 [Whisper](https://github.com/graphite-project/whisper) 也是 Python 写的，它画图和聚合能力都强了很多，但是很难扩展。
来自雅虎的[OpenTSDB](http://opentsdb.net/)使用 HBase 解决了扩展的问题。
[KairosDB](https://kairosdb.github.io/)最初是基于OpenTSDB修改的，但是作者认为兼容HBase导致他们不能使用很多Cassandra独有的特性，于是就抛弃了HBase仅支持Cassandra。有趣的是，在[新发布的]((http://opentsdb.net/docs/build/html/new.html)) OpenTSDB 中也加入了对 Cassandra 的支持。
故事还没完，Spotify 的人本来想使用 KairosDB，但是觉得[项目发展方向意见不合以及性能太差]((https://labs.spotify.com/2015/11/16/monitoring-at-spotify-the-story-so-far/))，就自己撸了一个 [Heroic](https://github.com/spotify/heroic)。
[InfluxDB](https://github.com/influxdata/influxdb) 早期是完全开源的，后来为了维持公司运营，闭源了集群版本。
在今年的 Percona Live 上，有一个[开源数据库商业模型正面临危机](https://www.youtube.com/watch?v=Kvf5jWZjw0U)的演讲，里面调侃红帽的段子很不错。
并且今年的 Percona Live 有个专门的[时间序列数据库单元](https://www.percona.com/live/17/program/schedule/time-series)。

## 时间序列数据库数据模型



## 时间序列数据库类型

## 热点话题

## 参考

- [Awesome Time Series Database](https://github.com/xephonhq/awesome-time-series-database)
- [VividCortex - TSDB using MySQL](https://www.vividcortex.com/blog/2014/12/16/in-case-you-missed-it-building-a-time-series-database-in-mysql/)

## License

- This article is licensed under [CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/).
- Please contact <marketing@dongyue.io> for commerical use.
